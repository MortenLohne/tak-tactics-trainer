<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tak tactics trainer</title>

    <style media="screen">
        body {
            margin: 0;
            padding: 30px;
            font-family: sans-serif;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        #username-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="overlay">
        <div id="username-box">
            <h2>Enter your Playtak username</h2>
            <input type="text" id="username-input" placeholder="Enter username" />
            <button onclick="submitUsername()">Submit</button>
        </div>
    </div>
    <iframe id="ninja"
        src="https://ptn.ninja/&showPlayButton=false&disablePTN=true&disableText=true&showBoardPrefsBtn=true"
        width="100%" height="600px" style="width: 100%; height: 600px; max-height: 100vh" frameborder="0"
        allowfullscreen></iframe>
    <div id="puzzleSolved" style="display: none;">
        <h2>Puzzle Solved!</h2>
        <p>Congratulations! You have successfully solved the puzzle.</p>
        <button id="nextPuzzleSuccess">Next
            puzzle</button>
    </div>
    <div id="puzzleFailed" style="display: none;">
        <h2>Puzzle Failed</h2>
        <p>Unfortunately, you did not solve the puzzle correctly.</p>
        <button id="nextPuzzleFailed">Next
            puzzle</button>
        <button id="retryPuzzle" onclick="switchPuzzle()">Retry Puzzle</button>
    </div>

    <script type="text/javascript">
        let username;
        const submitUsername = () => {
            username = document.getElementById('username-input').value.trim();
            if (username) {
                console.log("Username:", username);
                document.getElementById('overlay').style.display = 'none';
                if (ptnNinjaHasLoaded) {
                    // If ptn.ninja is already loaded, switch to the first puzzle
                    // Otherwise, this happens when `ptnNinjaHasLoaded` becomes true
                    nextPuzzle();
                }
            } else {
                console.log("No username entered");
                alert("Please enter a username.");
            }
        }

        // Enable Enter key to submit username
        document.getElementById('username-input').addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                submitUsername();
            }
        });

        let ptnNinjaHasLoaded = false;
        let messagesReceived = 0;
        let currentPuzzle;
        let currentPuzzlePly = 0;
        let lastMoveWasFinalMove = false;

        const nextPuzzle = async () => {
            const puzzleResponse = await fetch(`http://79.161.44.204:3000/puzzles?username=${username}`);
            if (!puzzleResponse.ok) {
                console.log("All puzzles already solved!");
                throw new Error(`Response status: ${response.status}`);
            }
            const puzzle = await puzzleResponse.json();
            console.log("Puzzle response:", JSON.stringify(puzzle));
            currentPuzzle = puzzle;

            switchPuzzle();
        }
        const nextPuzzleSuccessButton = document.getElementById("nextPuzzleSuccess");
        nextPuzzleSuccessButton.addEventListener("click", async () => {
            await nextPuzzle();
        });
        const nextPuzzleFailedButton = document.getElementById("nextPuzzleFailed");
        nextPuzzleFailedButton.addEventListener("click", async () => {
            await nextPuzzle();
        });

        const switchPuzzle = () => {
            currentPuzzlePly = 0;
            document.getElementById('puzzleFailed').style.display = 'none';
            document.getElementById('puzzleSolved').style.display = 'none';

            const ninja = document.getElementById("ninja");
            ninja.contentWindow.postMessage({
                action: 'SET_UI',
                value: {
                    disableBoard: false,
                }
            }, '*');

            const tpsWords = currentPuzzle.rootTPS.split(' ');
            const moveNumber = tpsWords[tpsWords.length - 1];
            const colorId = tpsWords[tpsWords.length - 2] === "2" ? 1 : 2;
            const color = colorId === 1 ? 'white' : 'black';

            const ptn = `[Size "${currentPuzzle.size}"]
            [Komi "${currentPuzzle.komi}"]
            [TPS "${currentPuzzle.rootTPS}"]
            [Player1 "${currentPuzzle.playerWhite}"]
            [Player2 "${currentPuzzle.playerBlack}"]
${moveNumber}. ${currentPuzzle.defenderStartMove}
            `;

            ninja.contentWindow.postMessage({
                action: 'SET_CURRENT_PTN',
                value: ptn
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'SET_NAME',
                value: `Find the best move for ${color}! Puzzle #${currentPuzzle.id}`,
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'LAST',
            }, '*');
        }

        const postSolution = (wasSolved) => {
            let payload = {
                id: currentPuzzle.id,
                username,
                solved: wasSolved,
                solution: [],
                solveTimeSeconds: 0,
            };
            console.log("Posting solution:", JSON.stringify(payload));

            fetch(`http://79.161.44.204:3000/puzzles/${currentPuzzle.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            })
                .catch(error => {
                    console.error('Error solving puzzle:', error);
                });
        }

        const markSolved = () => {
            document.getElementById("puzzleSolved").style.display = "block";

            const ninja = document.getElementById("ninja");
            ninja.contentWindow.postMessage({
                action: 'NOTIFY_SUCCESS',
                value: { message: `Puzzle solved!`, timeout: 5000 }
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'SET_UI',
                value: {
                    disableBoard: true,
                }
            }, '*');

            postSolution(true);
        }

        const markFailed = (finalMove) => {
            document.getElementById("puzzleFailed").style.display = "block";

            const ninja = document.getElementById("ninja");
            ninja.contentWindow.postMessage({
                action: 'NOTIFY_ERROR',
                value: { message: `Incorrect move: ${finalMove}`, timeout: 2000 }
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'SET_UI',
                value: {
                    disableBoard: true,
                }
            }, '*');

            postSolution(false);
        }

        window.addEventListener(
            "message",
            async (event) => {
                if (event.source !== ninja.contentWindow) {
                    return
                }
                messagesReceived += 1;

                // Consider the PTN ninja embed loaded after first GAME_STATE message
                // Only initialize puzzles after this point
                if (!ptnNinjaHasLoaded) {
                    if (event.data.action === "GAME_STATE") {
                        ptnNinjaHasLoaded = true;
                        if (username) {
                            await nextPuzzle();
                        }

                    } else {
                        return; // Ignore other messages until ptn.ninja is fully loaded
                    }
                }
                if (event.data.action === "PREV") {
                    currentPuzzlePly -= 1;
                    // Don't allow skipping past the defender's initial move
                    if (currentPuzzlePly === -1) {
                        ninja.contentWindow.postMessage({
                            action: 'NEXT',
                            value: ""
                        }, '*');
                    }
                }
                if (event.data.action === "FIRST") {
                    currentPuzzlePly = -1;
                    // Immediately insert the defender's initial move
                    ninja.contentWindow.postMessage({
                        action: 'NEXT',
                        value: ""
                    }, '*');
                }
                if (event.data.action === "NEXT") {
                    currentPuzzlePly += 1;
                    // Skip past the defender's move
                    if (currentPuzzlePly % 2 === 1 && currentPuzzlePly < currentPuzzle.solution.length && document.getElementById('puzzleFailed').style.display === 'none') {
                        ninja.contentWindow.postMessage({
                            action: 'INSERT_PLY',
                            value: currentPuzzle.solution[currentPuzzlePly]
                        }, '*');
                    }
                }
                if (event.data.action === "GAME_STATE" && lastMoveWasFinalMove) {
                    // This only happens after the player's last move, when the solution move was a wildcard
                    // Check that the last move was actually winning
                    const tpsWords = currentPuzzle.rootTPS.split(' ');
                    const colorId = tpsWords[tpsWords.length - 2] === "2" ? 1 : 2;
                    if (event.data.value.result?.winner === colorId) {
                        await markSolved();
                    } else {
                        markFailed(event.data.value.ply);
                    }
                    lastMoveWasFinalMove = false;
                }
                if (event.data.action === "INSERT_PLY") {
                    if (lastMoveWasFinalMove) {
                        console.log("Received unexpected INSERT_PLY after final move");
                    }
                    if (currentPuzzle.solution[currentPuzzlePly] === "*") {
                        // Player's final move, where the solution is any move that wins immediately
                        // We don't know if it was actually winning until the next GAME_STATE message
                        lastMoveWasFinalMove = true;
                    }
                    else if (event.data.value.replaceAll("*", "") === currentPuzzle.solution[currentPuzzlePly]) {
                        if (currentPuzzlePly === currentPuzzle.solution.length - 1) {
                            // Puzzle solved
                            await markSolved();
                        }
                        else if (currentPuzzlePly % 2 === 0) {
                            // Even ply are the player's moves
                            ninja.contentWindow.postMessage({
                                action: 'NOTIFY_SUCCESS',
                                value: { message: `Correct move: ${event.data.value} `, timeout: 2000 }
                            }, '*');
                            // Wait before inserting the next ply, disable the board in the meantime
                            ninja.contentWindow.postMessage({
                                action: 'SET_UI',
                                value: {
                                    disableBoard: true,
                                }
                            }, '*');
                            setTimeout(() => {
                                ninja.contentWindow.postMessage({
                                    action: 'INSERT_PLY',
                                    value: currentPuzzle.solution[currentPuzzlePly]
                                }, '*');
                            }, 300);
                        } else {
                            // Odd ply are the opponent's moves
                            ninja.contentWindow.postMessage({
                                action: 'SET_UI',
                                value: {
                                    disableBoard: false,
                                }
                            }, '*');
                        }
                    } else {
                        markFailed(event.data.value);
                    }
                    currentPuzzlePly += 1;
                }
            },
            false
        );

    </script>
</body>

</html>