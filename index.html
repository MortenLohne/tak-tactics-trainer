<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tak tactics trainer</title>

    <style media="screen">
        body {
            margin: 0;
            padding: 30px;
            font-family: sans-serif;
        }

        .row {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
        }

        body>.row {
            flex-grow: 1;
            min-width: 200px;
            flex-wrap: wrap;
            margin-top: 1em;
        }

        body>.row>* {
            flex-grow: 1;
            min-width: 200px;
        }

        .row input,
        .row textarea {
            width: 100% !important;
            margin-bottom: 1em;
        }

        #sendMessage,
        #clearOutput {
            position: sticky;
            top: 1em;
        }

        #output {
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <iframe id="ninja"
        src="https://ptn.ninja/&showPlayButton=false&disablePTN=true&disableText=true&showBoardPrefsBtn=true"
        width="100%" height="600px" style="width: 100%; height: 600px; max-height: 100vh" frameborder="0"
        allowfullscreen></iframe>
    <div id="puzzleSolved" style="display: none;">
        <h2>Puzzle Solved!</h2>
        <p>Congratulations! You have successfully solved the puzzle.</p>
        <button id="nextPuzzleSuccess">Next
            puzzle</button>
    </div>
    <div id="puzzleFailed" style="display: none;">
        <h2>Puzzle Failed</h2>
        <p>Unfortunately, you did not solve the puzzle correctly.</p>
        <button id="nextPuzzleFailed">Next
            puzzle</button>
        <button id="retryPuzzle" onclick="switchPuzzle()">Retry Puzzle</button>
    </div>
    <div class="row" style="display: none;">
        <fieldset>
            <legend>Send Message</legend>
            <form id=" sendMessage" method="post">
                <input name="action" placeholder="Action" />
                <textarea name="value" placeholder="Value"></textarea>
                <div class="row">
                    <input type="reset" value="Clear" />
                    <input type="submit" value="Send" />
                </div>
            </form>
        </fieldset>

        <fieldset>
            <legend>Received Messages</legend>
            <input id="clearOutput" type="button" value="Clear" onclick="output.value = ''" />
            <output id="output"></output>
        </fieldset>
    </div>

    <script type="text/javascript">
        const form = document.getElementById("sendMessage");
        let ptnNinjaHasLoaded = false;
        let messagesReceived = 0;
        let currentPuzzleIndex = 0;
        let allPuzzles = [];
        let currentPuzzle;
        let currentPuzzlePly = 0;
        let lastMoveWasFinalMove = false;

        const nextPuzzle = async () => {
            currentPuzzleIndex += 1;
            if (currentPuzzleIndex >= allPuzzles.length) {
                currentPuzzleIndex = 0; // Loop back to the first puzzle
            }

            const puzzleResponse = await fetch(`http://localhost:3000/puzzles?username=Mort4`);
            console.log("Puzzle response status:", puzzleResponse.status);
            console.log(puzzleResponse.ok);
            if (!puzzleResponse.ok) {
                throw new Error(`Response status: ${response.status}`);
            }
            const puzzle = await puzzleResponse.json();
            console.log("Puzzle response:", JSON.stringify(puzzle));
            currentPuzzle = puzzle;

            switchPuzzle();
        }
        const nextPuzzleSuccessButton = document.getElementById("nextPuzzleSuccess");
        nextPuzzleSuccessButton.addEventListener("click", async () => {
            await nextPuzzle();
        });
        const nextPuzzleFailedButton = document.getElementById("nextPuzzleFailed");
        nextPuzzleFailedButton.addEventListener("click", async () => {
            await nextPuzzle();
        });

        const switchPuzzle = () => {
            currentPuzzlePly = 0;
            document.getElementById('puzzleFailed').style.display = 'none';
            document.getElementById('puzzleSolved').style.display = 'none';

            const ninja = document.getElementById("ninja");
            ninja.contentWindow.postMessage({
                action: 'SET_UI',
                value: {
                    disableBoard: false,
                }
            }, '*');

            const tpsWords = currentPuzzle.rootTPS.split(' ');
            const moveNumber = tpsWords[tpsWords.length - 1];
            const colorId = tpsWords[tpsWords.length - 2] === "2" ? 1 : 2;
            const color = colorId === 1 ? 'white' : 'black';

            const ptn = `[Size "${currentPuzzle.size}"]
            [Komi "${currentPuzzle.komi}"]
            [TPS "${currentPuzzle.rootTPS}"]
            [Player1 "${currentPuzzle.playerWhite}"]
            [Player2 "${currentPuzzle.playerBlack}"]
${moveNumber}. ${currentPuzzle.defenderStartMove}
            `;

            ninja.contentWindow.postMessage({
                action: 'SET_CURRENT_PTN',
                value: ptn
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'SET_NAME',
                value: `Find the best move for ${color}! Puzzle #${currentPuzzleIndex + 1}`,
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'LAST',
            }, '*');
        }

        const postSolution = (wasSolved) => {
            let payload = {
                id: currentPuzzle.id,
                username: "Mort4",
                solved: wasSolved,
                solution: [],
                solveTimeSeconds: 0,
            };
            console.log("Posting solution:", JSON.stringify(payload));

            fetch(`http://localhost:3000/puzzles/${currentPuzzle.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            })
                .catch(error => {
                    console.error('Error solving puzzle:', error);
                });
        }

        const initPuzzles = () => {
            fetch('puzzles.json')
                .then(response => response.json())
                .then(puzzles => {
                    console.log(`${puzzles.length} puzzles loaded`);
                    allPuzzles = puzzles;
                    currentPuzzle = puzzles[0];
                    switchPuzzle();
                })
                .catch(error => {
                    console.error('Error fetching puzzles:', error);
                });
        };

        const markSolved = () => {
            document.getElementById("puzzleSolved").style.display = "block";

            const ninja = document.getElementById("ninja");
            ninja.contentWindow.postMessage({
                action: 'NOTIFY_SUCCESS',
                value: { message: `Puzzle solved!`, timeout: 5000 }
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'SET_UI',
                value: {
                    disableBoard: true,
                }
            }, '*');

            postSolution(true);
        }

        const markFailed = (finalMove) => {
            document.getElementById("puzzleFailed").style.display = "block";

            const ninja = document.getElementById("ninja");
            ninja.contentWindow.postMessage({
                action: 'NOTIFY_ERROR',
                value: { message: `Incorrect move: ${finalMove}`, timeout: 2000 }
            }, '*');
            ninja.contentWindow.postMessage({
                action: 'SET_UI',
                value: {
                    disableBoard: true,
                }
            }, '*');

            postSolution(false);
        }

        window.addEventListener(
            "message",
            async (event) => {
                if (event.source !== ninja.contentWindow) {
                    return
                }
                messagesReceived += 1;
                document.getElementById("output").value +=
                    "" + messagesReceived + " messages received,\n" + JSON.stringify(event.data, null, 2) + "\n";

                // Consider the PTN ninja embed loaded after first GAME_STATE message
                // Only initialize puzzles after this point
                if (!ptnNinjaHasLoaded) {
                    if (event.data.action === "GAME_STATE") {
                        ptnNinjaHasLoaded = true;
                        initPuzzles();
                    } else {
                        return; // Ignore other messages until ptn.ninja is fully loaded
                    }
                }
                if (event.data.action === "PREV") {
                    currentPuzzlePly -= 1;
                    // Don't allow skipping past the defender's initial move
                    if (currentPuzzlePly === -1) {
                        ninja.contentWindow.postMessage({
                            action: 'NEXT',
                            value: ""
                        }, '*');
                    }
                }
                if (event.data.action === "FIRST") {
                    currentPuzzlePly = -1;
                    // Immediately insert the defender's initial move
                    ninja.contentWindow.postMessage({
                        action: 'NEXT',
                        value: ""
                    }, '*');
                }
                if (event.data.action === "NEXT") {
                    currentPuzzlePly += 1;
                    // Skip past the defender's move
                    if (currentPuzzlePly % 2 === 1 && currentPuzzlePly < currentPuzzle.solution.length && document.getElementById('puzzleFailed').style.display === 'none') {
                        ninja.contentWindow.postMessage({
                            action: 'INSERT_PLY',
                            value: currentPuzzle.solution[currentPuzzlePly]
                        }, '*');
                    }
                }
                if (event.data.action === "GAME_STATE" && lastMoveWasFinalMove) {
                    // This only happens after the player's last move, when the solution move was a wildcard
                    // Check that the last move was actually winning
                    const tpsWords = currentPuzzle.rootTPS.split(' ');
                    const colorId = tpsWords[tpsWords.length - 2] === "2" ? 1 : 2;
                    if (event.data.value.result?.winner === colorId) {
                        await markSolved();
                    } else {
                        markFailed(event.data.value.ply);
                    }
                    lastMoveWasFinalMove = false;
                }
                if (event.data.action === "INSERT_PLY") {
                    if (lastMoveWasFinalMove) {
                        console.log("Received unexpected INSERT_PLY after final move");
                    }
                    if (currentPuzzle.solution[currentPuzzlePly] === "*") {
                        // Player's final move, where the solution is any move that wins immediately
                        // We don't know if it was actually winning until the next GAME_STATE message
                        lastMoveWasFinalMove = true;
                    }
                    else if (event.data.value.replaceAll("*", "") === currentPuzzle.solution[currentPuzzlePly]) {
                        if (currentPuzzlePly === currentPuzzle.solution.length - 1) {
                            // Puzzle solved
                            await markSolved();
                        }
                        else if (currentPuzzlePly % 2 === 0) {
                            // Even ply are the player's moves
                            ninja.contentWindow.postMessage({
                                action: 'NOTIFY_SUCCESS',
                                value: { message: `Correct move: ${event.data.value} `, timeout: 2000 }
                            }, '*');
                            // Wait before inserting the next ply, disable the board in the meantime
                            ninja.contentWindow.postMessage({
                                action: 'SET_UI',
                                value: {
                                    disableBoard: true,
                                }
                            }, '*');
                            setTimeout(() => {
                                ninja.contentWindow.postMessage({
                                    action: 'INSERT_PLY',
                                    value: currentPuzzle.solution[currentPuzzlePly]
                                }, '*');
                            }, 300);
                        } else {
                            // Odd ply are the opponent's moves
                            ninja.contentWindow.postMessage({
                                action: 'SET_UI',
                                value: {
                                    disableBoard: false,
                                }
                            }, '*');
                        }
                    } else {
                        markFailed(event.data.value);
                    }
                    currentPuzzlePly += 1;
                }
            },
            false
        );

        form.addEventListener(
            "submit",
            (event) => {
                event.preventDefault();
                const ninja = document.getElementById("ninja");
                const data = new FormData(event.target);
                const action = data.get("action");
                const valueString = data.get("value");
                let value;
                try {
                    value = JSON.parse(valueString);
                } catch (error) {
                    value = valueString;
                }
                try {
                    ninja.contentWindow.postMessage({ action, value }, "*");
                } catch (error) {
                    console.error(error);
                }
                return false;
            },
            true
        );

    </script>
</body>

</html>